@ngdoc overview
@name Tutorial: 2 - Шаблоны Angular-а
@description

<ul doc-tutorial-nav="2"></ul>

Теперь настало время, чтобы сделать нашу веб-страницу динамичной - с помощью AngularJS. Мы также добавим тест, 
который будет проверять код контроллера, который мы собираемся добавить.

Есть много способов как структурировать код приложения. Для Angular приложений, мы призываем использовать {@link 
http://en.wikipedia.org/wiki/Model–View–Controller Шаблон проектирования "Модель-Представление-Контроллер" (MVC)}, 
который разделяет модель данных приложения, пользовательский интерфейс и взаимодействие с пользователем на три 
отдельных компонента и тем самым разделяет и локализует возможные проблемы. Имея в виду этот подход (MVC), 
давайте, используя немного Angular-а и JavaScript-а, добавим модель (model), представление (view) и 
контроллер (controller) в наше приложение.

<div class="tabbable" show="true">

  <div class="tab-pane well" id="git-mac" title="Git на Mac/Linux">
    <ol>
      <li><p>Откатите ваш рабочий код до шага 2.</p>
          <pre>git checkout -f step-2</pre>
      </li>
      <li><p>Перезагрузите страницу или проверьте приложение на 
             <a href="http://angular.github.com/angular-phonecat/step-2/app">сервере Angular</a>.
          </p>
      </li>
    </ol>
  </div>
  
  <div class="tab-pane well" id="git-win" title="Git на Windows">
    <ol>
      <li><p>Откатите ваш рабочий код до шага 2.</p>
          <pre>git checkout -f step-2</pre>
      </li>
      <li><p>Перезагрузите страницу или проверьте приложение на 
             <a href="http://angular.github.com/angular-phonecat/step-2/app">сервере Angular</a>.
          </p>
      </li>
    </ol>
  </div>
  
</div>


Сейчас ваше приложение содержит список с тремя телефонами.

Наиболее важные изменения перечислены ниже. Вы можете увидеть полный список изменений перейдя по ссылке {@link
https://github.com/angular/angular-phonecat/compare/step-1...step-2 GitHub}:


## Представление и Шаблон

В Angular-е, __представление__ (__view__) это проекция модели (model) через HTML __шаблон__ (__template__). 
Это означает, что всякий раз, когда модель изменяется, Angular обновляет соответствующие связывания (binding points), 
которые обновляют представление (view).

Представление (view) строится Angular-ом из шаблона. Для нашего приложения шаблон представлен ниже:

__`app/index.html`:__
<pre>
<html ng-app>
<head>
  ...
  <script src="lib/angular/angular.js"></script>
  <script src="js/controllers.js"></script>
</head>
<body ng-controller="PhoneListCtrl">

  <ul>
    <li ng-repeat="phone in phones">
      {{phone.name}}
      <p>{{phone.snippet}}</p>
    </li>
  </ul>
</body>
</html>
</pre>

Мы заменили список телефонов, который раньше был набран нами в ручную (hard-coded), на 
{@link api/ng.directive:ngRepeat ngRepeat директиву} и два {@link guide/expression Angular выраженения}, 
заключенных в фигурные скобки: `{{phone.name}}` и `{{phone.snippet}}`:

* Оператор `ng-repeat="phone in phones"` в теге `<li>` это Angular-повторитель (Angular repeater).
  Повторитель говорит Angular-у, что нужно создать элемент `<li>` для каждого телефона из списка, 
  используя первый тег `<li>` как шаблон (основу).

* Как мы узнали в шаге 0, фигурные скобки вокруг выражений `phone.name` и `phone.snippet` означают 
  связывание данных (bindings). В отличие от константного значения, эти выражения ссылаются на модель нашего
  приложения, которая была создана в контроллере `PhoneListCtrl`.

      <img class="diagram" src="img/tutorial/tutorial_02.png">


##  Модель и Контроллер

Данные __модели__ (__model__) являются простым массивом телефонов. Каждое описание телефона представленно 
в виде объекта в литеральной нотации, т.е. объектом-литералом (object literal notation). Модель создается
в контроллере (__controller__) `PhoneListCtrl`:

__`app/js/controllers.js`:__
<pre>
function PhoneListCtrl($scope) {
  $scope.phones = [
    {"name": "Nexus S",
     "snippet": "Fast just got faster with Nexus S."},
    {"name": "Motorola XOOM™ with Wi-Fi",
     "snippet": "The Next, Next Generation tablet."},
    {"name": "MOTOROLA XOOM™",
     "snippet": "The Next, Next Generation tablet."}
  ];
}
</pre>




Хотя контроллер еще не сделал очень многого для управления, но он играет решающую роль. 
Говоря про определении контекста (context) для нашей модели, отметим, что контроллер позволяет нам 
установить связывание данных (data-binding) между моделью (model) и представлением (view). 
Мы соединили точки между представлением (presentation), данными и логическими элементами следующим образом:

* `PhoneListCtrl` - имя нашей функции для контроллера (находится в файле JavaScript 
  `controllers.js`), совпадает со значением директивы {@link api/ng.directive:ngController `ngController`},
  расположенной в теге `<body>`.

* Данные о телефоне устанавливаются и сохраняются в *областе видимости* (`$scope`), это происходит
  внутри функции нашего контроллера. Область видимости контроллера (controller scope) является 
  потомком корневой области видимости (root scope), которая была создана при инициализации приложения. 
  Область видимости контроллера (controller scope) доступна для всех связанных данных (bindings)
  в пределах тега `<body ng-controller="PhoneListCtrl">`.

Концепция *области видимости* (scope) является очень важной в Angular-е; *область видимости* (scope)
можно рассматривать как клей, который позволяет шаблону (template), модели (model) и 
контоллеру (controller) работать совместно. Angular использует *область видимости* (scope), 
вместе с информацией из шаболна, даннами из модели и контроллером, для синхронизации данных между 
моделями (models)и представлениями (views). Любые изменения, внесенные в модель отражаются 
в представлении, любые изменения, которые происходят в представлении отражаются в модели.

Узнать больше об *области видимости* в Angular можно здесь {@link 
api/ng.$rootScope.Scope документация по Scope}.



## Tests

The "Angular way" makes it easy to test code as it is being developed. Take a look at the following
unit test for your newly created controller:

__`test/unit/controllersSpec.js`:__
<pre>
describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){

    it('should create "phones" model with 3 phones', function() {
      var scope = {},
          ctrl = new PhoneListCtrl(scope);

      expect(scope.phones.length).toBe(3);
    });
  });
});
</pre>

The test verifies that we have three records in the phones array and the example demonstrates how
easy it is to create a unit test for code in Angular. Since testing is such a critical part of
software development, we make it easy to create tests in Angular so that developers are encouraged
to write them.

Angular developers prefer the syntax of Jasmine's Behavior-driven Development  (BDD) framework when
writing tests. Although Angular does not require you to use Jasmine, we wrote all of the tests in
this tutorial in Jasmine. You can learn about Jasmine on the {@link
http://pivotal.github.com/jasmine/ Jasmine home page} and on the {@link
https://github.com/pivotal/jasmine/wiki Jasmine wiki}.

The angular-seed project is pre-configured to run all unit tests using {@link
http://karma-runner.github.io/ Karma}. To run the test, do the following:

1. In a _separate_ terminal window or tab, go to the `angular-phonecat` directory and run
`./scripts/test.sh` to start the Karma server (the config file necessary to start the server
is located at `./config/testacular.conf.js`).

2. Karma will start a new instance of Chrome browser automatically. Just ignore it and let it run in
   the background. Karma will use this browser for test execution.

3. You should see the following or similar output in the terminal:

             info: Karma server started at http://localhost:9876/
             info (launcher): Starting  browser "Chrome"
             info (Chrome 22.0): Connected on socket id tPUm9DXcLHtZTKbAEO-n
             Chrome 22.0: Executed 1 of 1 SUCCESS (0.093 secs / 0.004 secs)

  Yay! The test passed! Or not...

4. To rerun the tests, just change any of the source or test files. Karma will notice the change
  and will rerun the tests for you. Now isn't that sweet?

# Experiments

* Add another binding to `index.html`. For example:

          <p>Total number of phones: {{phones.length}}</p>

* Create a new model property in the controller and bind to it from the template. For example:

          $scope.hello = "Hello, World!"

  Refresh your browser to make sure it says, "Hello, World!"

* Create a repeater that constructs a simple table:

          <table>
            <tr><th>row number</th></tr>
            <tr ng-repeat="i in [0, 1, 2, 3, 4, 5, 6, 7]"><td>{{i}}</td></tr>
          </table>

  Now, make the list 1-based by incrementing `i` by one in the binding:

          <table>
            <tr><th>row number</th></tr>
            <tr ng-repeat="i in [0, 1, 2, 3, 4, 5, 6, 7]"><td>{{i+1}}</td></tr>
          </table>

* Make the unit test fail by changing the `toBe(3)` statement to `toBe(4)`.


# Summary

You now have a dynamic app that features separate model, view, and controller components, and you
are testing as you go. Now, let's go to {@link step_03 step 3} to learn how to add full text search
to the app.


<ul doc-tutorial-nav="2"></ul>
