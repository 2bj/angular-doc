@ngdoc overview
@name Developer Guide: Понимание областей
@description

**Резюме:**

В AngularJS, дочерняя область видимости обычно прототипически наследуется от родительской. Единственным исключением 
является директива, в которой используется `scope: { ... }`, что создает «изолированную» область видимости,
которая не наследуется прототипически. Такая конструкция часто используется при создании директивы для компонента
«многоразового использования»

Наследование областей, как правило, прямое, и часто даже не нужно знать, как оно делается... пока не столкнешься
с **двухсторонней привязкой данных** (т. е. элементами формы, ng-model) **к примитивам** (напр., числу, строке, 
логическому типу), определенными в родительской области видимости из дочерней. Она работает не так, как этого
ожидают большинство людей. Происходит так, что потомок создает собственную область видимости, которая перекрывает
родительское свойство с одноименным названием. Это не особенность AngularJS, так работает прототипное наследование в 
JavaScript. Новые разработчики AngularJS часто не понимают, что ng-repeat, ng-switch, ng-view и ng-include 
создают новые дочерние области, так что проблема появляется при использовании этих директив.

Этой проблемы легко избежать, следуя «[лучшим практикам](http://habrahabr.ru/post/181882/)», где
говорится, что выражение в ng-model должно всегда содержать точку.

Точка «.» в модели гарантирует, что прототипное наследование работает как надо. Поэтому <br>
`<input type="text" ng-model="someObj.prop1">` лучше чем <br>
`<input type="text" ng-model="prop1">`.

Если действительно хотите/нужно использовать примитивы, есть два пути решения проблемы:

  1. Используйте `$parent.parentScopeProperty` в дочерней области видимости. Это запретит дочерней области создавать
     собственное свойство.
  2. Определите функцию в родительской области видимости, и обратитесь к ней из потомка, передавая элементарное 
     значение в родителя (не всегда возможно)

**Детали:**

* [Прототипное наследование в JavaScript](#JSproto)
* [Наследование областей видимости в Angular](#Angular)
  * [ng-include](#ngInclude)
  * [ng-switch](#ngSwitch)
  * [ng-repeat](#ngRepeat)
  * [ng-view](#ngView)
  * [ng-controller](#ngController)
  * [directives](#directives)

## <a id="JSproto"></a>Прототипное наследование в JavaScript

В первую очередь, важно иметь четкое представление о прототипном наследовании в JavaScript, особенно если 
пришли из серверного программирования и больше знакомы с классическим наследованием.

Предположим parentScope имеет свойства aString, aNumber, anArray, anObject, и aFunction. Если childScope
прототипически наследуется от parentScope, имеем:

![нормальное прототипное наследование](http://i.stack.imgur.com/aTAGg.png)

(Обратите внимание, что для экономии места, объект `anArray` показан как одиночный объект с тремя значениями,
а не объект с тремя строками.)

Если попытаться получить доступ к свойствам по умолчанию, определенным в parentScope, из дочерней области видимости,
JavaScript сначала ищет в дочерней области и, не найдя там, затем смотрит в родительской область и находит свойство. 
(Если бы не нашел в parentScope, то продолжил бы поиск по цепочке прототипов... вплоть до корневой области
видимости). Итак, все утверждения ниже верны:

    childScope.aString === 'parent string'
    childScope.anArray[1] === 20
    childScope.anObject.property1 === 'parent prop1'
    childScope.aFunction() === 'parent output'

Предположим, что после этого сделали так:

    childScope.aString = 'child string'

Цепочка прототипов не расматривается, а новое свойство aString добавляется в childScope. **Новое свойство 
перекрывает свойство из parentScope с таким же названием.** Это будет очень важным, при обсуждении ng-repeat и
ng-include ниже.

![перекрытие](http://i.stack.imgur.com/OyVPW.png)

Предположим, что после этого сделали так:

    childScope.anArray[1] = '22'
    childScope.anObject.property1 = 'child prop1'

Цепочка прототипов рассматривается, так как объекты (anArray и anObject) не найдены в childScope. Объекты
находятся в parentScope, а значения свойств обновляются в исходных объектах. Новые свойства не добавляются в
childScope; новые объекты не создаются. (Отметим, что в JavaScript массивы и функции также являются объектами.)

![следование по цепочке](http://i.stack.imgur.com/2QceU.png)

Предположим, что после этого сделали так:

    childScope.anArray = [100, 555]
    childScope.anObject = { name: 'Mark', country: 'USA' }

Цепочка прототипов опять не рассматривается, и дочерняя область видимости получает два новых свойства объекта, которые
перекрывают свойства  объекта из parentScope с теми же именами.

![не следование по цепочке](http://i.stack.imgur.com/hKetH.png)

Подытожим:

* Если читаем childScope.propertyX и childScope содержит propertyX, то цепочка прототипов не рассматривается.
* Если устанавливаем childScope.propertyX, цепочка прототипов рассматривается.

И последний сценарий:

    delete childScope.anArray
    childScope.anArray[1] === 22  // true

Сперва удалим свойство из childScope, а затем, когда попытаемся получить доступ к свойству снова, состоится переход
по цепочке прототипов.

![после удаления свойства](http://i.stack.imgur.com/56uoe.png)

## <a id="Angular"></a>Наследование областей видимости в Angular

Соучастники:

* Создают новые области видимости, которые прототипически наследуются: ng-repeat, ng-include, ng-switch,
  ng-view, ng-controller, директивы с `scope: true`, директивы с `transclude: true`.
* Создает новую область, которая не наследуется прототипически: директивы с `scope: { ... }`. Вместо этого они
  создают «изолированную» область видимости.

Обратите внимание, что по умолчанию, директивы не создают новые области, т.е. по умолчанию `scope: false`.

### <a id="ngInclude"></a>ng-include

Предположим, что имеем в контроллере:
<pre>
    $scope.myPrimitive = 50;
    $scope.myObject    = {aNumber: 11};
</pre>
И в HTML:
<pre>
    <script type="text/ng-template" id="/tpl1.html">
        <input ng-model="myPrimitive">
    </script>
    <div ng-include src="'/tpl1.html'"></div>

    <script type="text/ng-template" id="/tpl2.html">
        <input ng-model="myObject.aNumber">
    </script>
    <div ng-include src="'/tpl2.html'"></div>
</pre>
Каждая ng-include создает новую дочернюю область видимости, прототипически унаследованную от родительской области.

![ng-include](http://i.stack.imgur.com/ziDfx.png)

Набор (скажем, «77») в первом текстовом поле приведет к тому, что дочерняя область видимости получит новое свойство 
myPrimitive из области видимости, которое перекроет свойство родительской области с одноименным названием.

Вероятно, это не то, чего вы хотите или ожидаете.

![примитив в ng-include](http://i.stack.imgur.com/7l8dg.png)

Набор (скажем, «99») во втором текстовом поле не приводит к созданию новой дочерней области видимости. Потому что
tpl2.html связывает модель со свойством объекта, прототипное наследование заканчивается, когда ngModel ищет объект
MyObject — находит его в родительской области.

![объект в ng-include](http://i.stack.imgur.com/QjvVK.png)

**Примечание:** изображение выше нправильное, красное «99» должно быть все еще 50, вместо этого 11 должно быть 99.

Можно переписать первый шаблон с использованием $parent, если не хотим менять модель из примитива на объект:

    <input ng-model="$parent.myPrimitive">

Набор (скажем, «22») в этом текстовом поле не имеет последствий для нового дочернего свойства. Модель теперь связана 
со свойством родительской области (потому что $parent является свойством дочерней области видимости, ссылающимся 
на родительскую область).

![$parent в ng-include](http://i.stack.imgur.com/kd8pj.png)

Для всех областей видимости (прототипных или нет), Angular всегда отслеживает отношения родитель-ребенок 
(т. е. иерархию), через свойства $parent, $$childHead и $$childTail в области видимости. Эти свойства обычно не
показываются на диаграммах.

В случаях, когда элементы формы не задействуются, другим решением будет определение функции в родительской области
видимости для измения примитива. Только убедитесь, что потомок всегда вызывает эту функцию, которая будет 
доступна в дочерней области видимости в соответствии с прототипными наследованием. Например,

    // в родительской области видимости
    $scope.setMyPrimitive = function(value) {
        $scope.myPrimitive = value;
    }

Здесь [простой фидл](http://jsfiddle.net/mrajcok/jNxyE/), который использует подход с «родительской функцией».
(Являлся частью [поста на Stack Overflow](http://stackoverflow.com/a/14104318/215945).)

См. так же http://stackoverflow.com/a/13782671/215945 и<br> https://github.com/angular/angular.js/issues/1267.

### <a id="ngSwitch"></a> ng-switch

Наследование область видимости в ng-switch работает так жде как в ng-include. Так что если нуждаетесь в двухсторонней
привязке данных к примитиву в родительской области видимости, используйте $parent или измените модель на объект, 
а затем привяжите к свойству этого объекта. Это позволит избежать перекрытия свойст родительской области свойствами
дочерней.

См. так же [AngularJS, bind scope of a switch-case?](http://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410)

### <a id="ngRepeat"></a> ng-repeat

Ng-repeat работает немного по-другому. Предположим, что в контроллере содержится следующее:

    $scope.myArrayOfPrimitives = [ 11, 22 ];
    $scope.myArrayOfObjects    = [{num: 101}, {num: 202}]

И в HTML:

    <ul><li ng-repeat="num in myArrayOfPrimitives">
           <input ng-model="num">
        </li>
    <ul>
    <ul><li ng-repeat="obj in myArrayOfObjects">
           <input ng-model="obj.num">
        </li>
    <ul>
Для каждого элемента/итерации, ng-repeat создает новую область видимости, которая прототипически наследуется от
родительской, **но он также присваивает значение элемента новым свойствам в новой дочерней области**. (Названием
нового свойства является имя переменной из цикла.) Ниже показан фактический исходный код для ng-repeat:

    childScope = scope.$new(); // дочерняя область прототипически наследуется от родительсой ...     
    childScope[valueIdent] = value; // создает новое свойство в childScope

Если элемент является примитивом (как в myArrayOfPrimitives), по сути, копии значения присваивается новое свойство
дочерней области видимости. Изменение значения свойства в дочерней области (т. е., используя ng-model, следовательно
свойство `num` из дочерней области видимости) **не** изменяет массив ссылок в родительской области. Таким образом, 
в первом ng-repeat выше, каждая дочерняя область видимости получает свойство `num`, которое не зависит от массива 
myArrayOfPrimitives:

![примитив в ng-repeat](http://i.stack.imgur.com/nLoiW.png)

ng-repeat не будет работать (как хотите или ожидаем). В Angular 1.0.2 или более раннем, ввод в поля ввода, 
изменяет значения в серых блоках, которые видны только в дочерних областях. В Angular 1.0.3 +, ввод
в текстовые поля никак не влияет. (См. пояснения Артема, почему так на [StackOverflow](http://stackoverflow.com/a/13723990/215945).)
Мы же хотим, чтобы ввод влияюл на массив myArrayOfPrimitives, а не на свойство дочерней области видимости. 
Чтобы достичь этого, необходимо изменить модель на массив объектов.

Так, если элемент является объектом, ссылке на исходный объект (не копия) присваивается новое свойство дочерней
области видимости. Изменение значения свойства из дочерней области (т. е., используя ng-model, следовательно
свойство `num` из дочерней области видимости) **изменяет** объект по ссылке из родительской области. Так во втором
ng-repeat выше, мы имеем:

![объект в ng-repeat](http://i.stack.imgur.com/QSjTJ.png)

(серая линия показывает куда он переходит.)

Это работает, как ожидалось. Набор в поля ввода, изменяет значения в серой области, которые видны и в дочерней
и в родительской областях видимости.

См. так же [Сложности с ng-model, ng-repeat, и inputs](http://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs) и<br> [ng-repeat and databinding](http://stackoverflow.com/a/13782671/215945)

### <a id="ngView"></a> ng-view

Уточняется, но думаю, что действует так же, как ng-include.

### <a id="ngController"></a> ng-controller

Вложенные, с использованием ng-controller, контроллеры подчиняются закону нормального прототипного наследования,
как ng-include и ng-switch, так что применимы те же методы. Тем не менее «считается дурным обмениваться информацией
между двумя контроллерами через наследование $scope» — 
http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/. Вместо этого необходимо использовать сервис.

(Если действительно необходимо поделиться данными через наследование области видимости контроллеров, то делать
ничего не надо. Дочерняя область видимости будет иметь доступ ко всем свойствам в родительской области. См. также
[Controller load order differs when loading or navigating](http://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771))

### <a id="directives"></a> Диретивы

  1. default (`scope: false`) - the directive does not create a new scope, so there is no inheritance here. This is easy, but also dangerous because, e.g., a directive might think it is creating a new property on the scope, when in fact it is clobbering an existing property. This is not a good choice for writing directives that are intended as reusable components.
  2. `scope: true` - the directive creates a new child scope that prototypically inherits from the parent scope. If more than one directive (on the same DOM element) requests a new scope, only one new child scope is created. Since we have "normal" prototypal inheritance, this is like ng-include and ng-switch, so be wary of 2-way data binding to parent scope primitives, and child scope hiding/shadowing of parent scope properties.
  3. `scope: { ... }` - the directive creates a new isolate/isolated scope. It does not prototypically inherit. This is usually your best choice when creating reusable components, since the directive cannot accidentally read or modify the parent scope. However, such directives often need access to a few parent scope properties. The object hash is used to set up two-way binding (using '=') or one-way binding (using '@') between the parent scope and the isolate scope. There is also '&' to bind to parent scope expressions. So, these all create local scope properties that are derived from the parent scope. Note that attributes are used to help set up the binding -- you can't just reference parent scope property names in the object hash, you have to use an attribute. E.g., this won't work if you want to bind to parent property `parentProp` in the isolated scope: `<div my-directive>` and `scope: { localProp: '@parentProp' }`. An attribute must be used to specify each parent property that the directive wants to bind to: `<div my-directive the-Parent-Prop=parentProp>` and `scope: { localProp: '@theParentProp' }`.
<br>Isolate scope's `__proto__` references a [Scope](http://docs.angularjs.org/api/ng.$rootScope.Scope) object (the picture below needs to be updated to show an orange 'Scope' object instead of an 'Object'). Isolate scope's $parent references the parent scope, so although it is isolated and doesn't inherit prototypically from the parent scope, it is still a child scope.
<br>For the picture below we have 
<br>`<my-directive interpolated="{{parentProp1}}" twowayBinding="parentProp2">` and
<br> `scope: { interpolatedProp: '@interpolated', twowayBindingProp: '=twowayBinding' }` 
<br>Also, assume the directive does this in its linking function: `scope.someIsolateProp = "I'm isolated"`
<br>![isolate scope](http://i.stack.imgur.com/MUxS4.png)
<br>One final note: use `attrs.$observe('attr_name', function(value) { ... }` in the linking function to get the interpolated value of isolate scope properties that use the '@' notation.  E.g., if we have this in the linking function -- `attrs.$observe('interpolated', function(value) { ... }` -- `value` would be set to 11.  (`scope.interpolatedProp` is undefined in the linking function.  In contrast, `scope.twowayBindingProp` is defined in the linking function, since it uses the '=' notation.)
<br>For more information on isolate scopes see http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/
  4. `transclude: true` - the directive creates a new "transcluded" child scope, which prototypically inherits from the parent scope.  So if your transcluded content (i.e., the stuff that ng-transclude will be replaced with) requires 2-way data binding to a primitive in the parent scope, use $parent, or change the model to be an object and then bind to a property of that object. This will avoid child scope hiding/shadowing of parent scope properties.<br>The transcluded and the isolated scope (if any) are siblings -- the $parent property of each scope references the same parent scope. When a transcluded and an isolate scope both exist, isolate scope property $$nextSibling will reference the transcluded scope.
<br>For more information on transcluded scopes, see [AngularJS two way binding not working in directive with transcluded scope](http://stackoverflow.com/a/14484903/215945)
<br>For the picture below, assume the same directive as above with this addition: `transclude: true`
<br>![transcluded scope](http://i.stack.imgur.com/fkWHA.png)

This [fiddle](http://jsfiddle.net/mrajcok/7g3QM/) has a `showScope()` function that can be used to examine an isolate scope and its associated transcluded scope. See the instructions in the comments in the fiddle.

## Summary

There are four types of scopes:

  1. normal prototypal scope inheritance -- ng-include, ng-switch, ng-controller, directive with `scope: true`
  2. normal prototypal scope inheritance with a copy/assignment -- ng-repeat. Each iteration of ng-repeat creates a new child scope, and that new child scope always gets a new property.
  3. isolate scope -- directive with `scope: {...}`. This one is not prototypal, but '=', '@', and '&' provide a mechanism to access parent scope properties, via attributes.
  4. transcluded scope -- directive with `transclude: true`. This one is also normal prototypal scope inheritance, but it is also a sibling of any isolate scope.

For all scopes (prototypal or not), Angular always tracks a parent-child relationship (i.e., a hierarchy), via properties $parent and $$childHead and $$childTail.

Diagrams were generated with [GraphViz](http://graphviz.org) "*.dot" files, which are on [github](https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams). Tim Caswell's ["Learning JavaScript with Object Graphs"](http://howtonode.org/object-graphs) was the inspiration for using GraphViz for the diagrams.

The above was originally posted on [StackOverflow](http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs).
