@workInProgress
@ngdoc overview
@name Developer Guide: E2E тестирование
@description

Со временем сложность и размеры приложения растут, и становится нереально рассчитывать на ручное тестирование 
для проверки корректности новых функций, отлова ошибок и объяснение регрессий.

Для решения этой проблемы, мы сделали в Angular исполнитель сценариев, который имитирует взаимодействие с 
пользователями, и поможет проверить работоспособность приложения.

# Обзор
Вы будете писать JavaScript-сценарии тестов, которые описывают, как должно вести себя приложение, учитывая 
определенные взаимодействия в определенном состоянии. Сценарий состоит из одного или более `it` блоков (можно 
думать о них как о требованиях вашего приложения), которые, в свою очередь состоят из **команд** и **ожиданий**. 
Команда говорит исполнителю сценария, что нужно сделать с приложением (например, перейти на страницу или 
нажать на кнопку), и ожидает, пока исполнитель не сообщит значение текущего состояния (например, значение 
поля или текущий URL-адрес). В случае несоответствия результата ожиданиям, исполнитель помечает блок `it` как «failed» 
и продолжает следующий. Сценарии могут также иметь блоки **beforeEach** и **afterEach**, которые будут выполняться до 
(или после) каждого блока `it`, независимо от того, пройден он или нет.

<img src="img/guide/scenario_runner.png">

В дополнение к вышеперечисленному сценарии могут содержать вспомогательные функции, которые призваны исключить 
дублирование кода в блоках `it`.

Пример простого сценария:
<pre>
describe('Buzz Client', function() {
it('should filter results', function() {
  input('user').enter('jacksparrow');
  element(':button').click();
  expect(repeater('ul li').count()).toEqual(10);
  input('filterText').enter('Bees');
  expect(repeater('ul li').count()).toEqual(1);
});
});
</pre>
Сценарий определяет блок требований Buzz Client, который проверяет работу фильтра для поля user. При старте 
вводится значение в поле ввода 'user' и щелкается кнопка на странице, а затем проверяется наличие 10 элементов 
всписке. Затем вводится 'Bees' в поле 'filterText' и проверяется, что остался один элемент.

В секции API приведен список доступных команд и ожиданий для исполнителя.

# API
Исходный код: {@link https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js}

## pause()
Приостановка выполнения тестов до вызова функции `resume()` в консоли (или щелчке по ссылке resume в Runner UI).

## sleep(seconds)
Приостановка выполнения тестов через указанное количество секунд `seconds`.

## browser().navigateTo(url)
Loads the `url` into the test frame.

## browser().navigateTo(url, fn)
Loads the URL returned by `fn` into the testing frame. The given `url` is only used for the test
output. Use this when the destination URL is dynamic (that is, the destination is unknown when you
write the test).

## browser().reload()
Refreshes the currently loaded page in the test frame.

## browser().window().href()
Returns the window.location.href of the currently loaded page in the test frame.

## browser().window().path()
Returns the window.location.pathname of the currently loaded page in the test frame.

## browser().window().search()
Returns the window.location.search of the currently loaded page in the test frame.

## browser().window().hash()
Returns the window.location.hash (without `#`) of the currently loaded page in the test frame.

## browser().location().url()
Returns the {@link api/ng.$location $location.url()} of the currently loaded page in
the test frame.

## browser().location().path()
Returns the {@link api/ng.$location $location.path()} of the currently loaded page in
the test frame.

## browser().location().search()
Returns the {@link api/ng.$location $location.search()} of the currently loaded page
in the test frame.

## browser().location().hash()
Returns the {@link api/ng.$location $location.hash()} of the currently loaded page in
the test frame.

## expect(future).{matcher}
Asserts the value of the given `future` satisfies the `matcher`. All API statements return a
`future` object, which get a `value` assigned after they are executed. Matchers are defined using
`angular.scenario.matcher`, and they use the value of futures to run the expectation. For example:
`expect(browser().location().href()).toEqual('http://www.google.com')`

## expect(future).not().{matcher}
Asserts the value of the given `future` satisfies the negation of the `matcher`.

## using(selector, label)
Scopes the next DSL element selection.

## binding(name)
Returns the value of the first binding matching the given `name`.

## input(name).enter(value)
Enters the given `value` in the text field with the given `name`.

## input(name).check()
Checks/unchecks the checkbox with the given `name`.

## input(name).select(value)
Selects the given `value` in the radio button with the given `name`.

## input(name).val()
Returns the current value of an input field with the given `name`.

## repeater(selector, label).count()
Returns the number of rows in the repeater matching the given jQuery `selector`. The `label` is
used for test output.

## repeater(selector, label).row(index)
Returns an array with the bindings in the row at the given `index` in the repeater matching the
given jQuery `selector`. The `label` is used for test output.

## repeater(selector, label).column(binding)
Returns an array with the values in the column with the given `binding` in the repeater matching
the given jQuery `selector`. The `label` is used for test output.

## select(name).option(value)
Picks the option with the given `value` on the select with the given `name`.

## select(name).option(value1, value2...)
Picks the options with the given `values` on the multi select with the given `name`.

## element(selector, label).count()
Returns the number of elements that match the given jQuery `selector`. The `label` is used for test
output.

## element(selector, label).click()
Clicks on the element matching the given jQuery `selector`. The `label` is used for test output.

## element(selector, label).query(fn)
Executes the function `fn(selectedElements, done)`, where selectedElements are the elements that
match the given jQuery `selector` and `done` is a function that is called at the end of the `fn`
function.  The `label` is used for test output.

## element(selector, label).{method}()
Returns the result of calling `method` on the element matching the given jQuery `selector`, where
`method` can be any of the following jQuery methods: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`. The `label` is used for test output.

## element(selector, label).{method}(value)
Executes the `method` passing in `value` on the element matching the given jQuery `selector`, where
`method` can be any of the following jQuery methods: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`.  The `label` is used for test output.

## element(selector, label).{method}(key)
Returns the result of calling `method` passing in `key` on the element matching the given jQuery
`selector`, where `method` can be any of the following jQuery methods: `attr`, `prop`, `css`. The
`label` is used for test output.

## element(selector, label).{method}(key, value)
Executes the `method` passing in `key` and `value` on the element matching the given jQuery
`selector`, where `method` can be any of the following jQuery methods: `attr`,  `prop`, `css`.  The
`label` is used for test output.

JavaScript is a dynamically typed language which comes with great power of expression, but it also
come with almost no-help from the compiler. For this reason we feel very strongly that any code
written in JavaScript needs to come with a strong set of tests. We have built many features into
angular which makes testing your angular applications easy. So there is no excuse for not testing.
