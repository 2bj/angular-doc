@ngdoc overview
@name Developer Guide: Понимание директив
@description

### [Взято из AngularUI](https://github.com/angular-ui/angular-ui/blob/master/modules/directives/jq/README.md)

Этот документ (косвенно) пытается объяснить, как директивы AngularJS и связанный движок компиляции, работают так, 
чтобы вы не разбрасывали лапшу по кругу, когда в первый раз попытатаетесь взяться за дело самостоятельно.

## Внедряющая, компилирующая и связующая функции

Когда создается директива, по сути, определяется три функциональных слоя (на самом деле 
[включающая функция](http://docs.angularjs.org/guide/directive) является четвертым слоем, но она не используется uiJq).

<pre>
myApp.directive('uiJq', function InjectingFunction(){

  // === ВнедряющаяФункция === //
  // Выполняется только один раз в приложении или не выполняется (в зависимости от того, используется ли директива).
  // Полезна для инициализации и глобальной настройки

  return {
    compile: function CompilingFunction($templateElement, $templateAttributes) {

      // === ФункцияКомпиляции === //
      // Выполняется один раз для каждого экземпляра ui-jq в исходном НЕОТРЕНДЕРЕНОМ шаблоне. 
      // Область видимости НЕДОСТУПНА, т. к. шаблоны только в кэше. МОЖНО исследовать DOM и информацию из кэша
      //   о том, какие переменные и выражения будут использоваться, но пока нельзя определить их значения.
      // Angular закэшировал шаблоны и сейчас самое подходящее время, чтобы внедрить новые шаблоны в качестве потомков
      //   или будущих соседей для автоматического запуска.

      return function LinkingFunction($scope, $linkElement, $linkAttributes) {

        // === СвязующаяФункция === //
        // Выполняется один раз для каждого ОТРЕНДЕРЕНОГО экземпляра.
        // Один раз для каждой строки ng-repeat при её создании.
        // ng-if или ng-switch при выполнении также могут влиять.
        // Область вилдимости ДОСТУПНА, потому что логическа контроллера уже отработала.
        // Все переменные и значения выражений могут быть окончательно определены.
        // Angular отрендерил кэш шаблонов. Уже поздно добавлять шаблоны для автоматического запуска.
        //  Если НЕОБХОДИМО внедрить новые шаблоны, нужно использовать $compile вручную
      };
    }
  };
})
</pre>

Доступ к данным можно получить _только_ в `$scope` внутри **СвязующейФункции**. Так как логика шаблона может удалять
или копировать элементы, то можно рассчитывать _только_ на окончательно настроенный DOM в **СвязующейФункции**. 
Всё еще _нельзя_ рассчитывать на потмков или соседей, так как они еще не связаны.

## Пре- и Пост-связующие функции
Везде, где можно использовать `LinkingFunction()`, вместо нее можно использовать объект с пре- и пост-связующими
функциями. [Как ни странно](https://github.com/angular/angular.js/issues/2592), `LinkingFunction()` является
`PostLinkingFunction()` по умолчанию:
<pre>
link: function LinkingFunction($scope, $element, $attributes) { ... }
...
link: {
  pre: function PreLinkingFunction($scope, $element, $attributes) { ... },
  post: function PostLinkingFunction($scope, $element, $attributes) { ... },
}
</pre>

Разница в том, что `PreLinkingFunction()` будет сначала обрабатывать родителя, а затем потомка и так далее.
`PostLinkingFunction()` идет в обратном направлении, обрабатывая сначала потомка, а затем родителя, и так далее.
Вот демо: {@link http://plnkr.co/edit/qrDMJBlnwdNlfBqEEXL2?p=preview}

**Когда нужно использовать обратное `PostLinking` поведение?** Иногда JQuery-плагину необходимо знать количество 
и размер потомков DOM элемента (например, слайд-шоу или менеджеру слоев, такому как Isotope). Есть несколько способов,
сделать поддержку этого:

* **(Наихудший)** Задержка выполнения плагина с использованием [$timeout](http://docs.angularjs.org/api/ng.$timeout)
* Вложенные директивы. Когда у каждого потомка есть директива, которая требует родительскую
  `require: '^parentDirective'` которая предоставит доступ к контроллеру `parentDirective`.
  * Если используется `PreLinkingFunction()` в `parentDirective`, можно создать пустой экземпляр контейнера,
  и затем обновлять его все время.

**Всё это _НЕ_ подходит для асинхронного изменения, такого как загрузка данных в `$scope` через AJAX**

Если необходимо подождать, пока в `$scope` не поступят данные, воспользуйтесь `ng-if` для отложенной загрузки 
блока DOM.

## $element === angular.element() === jQuery() === $()

Чтобы сделать работу с DOM проще, AngularJS содержит упрощенную версию JQuery, под названием jqlite. Она позволяет 
эмулировать некоторые из основных особенностей JQuery, используя _практически_ идентичный API. Каждый 
раз, когда видите DOM-элемент AngularJS, он будет эквивалентен элементу, обернутому в `JQuery()`.

**_НЕ_ следует оборачивать элементы AngularJS в `jQuery()`**

Если заметили, что полный набор методов JQuery (или плагинов) не доступен в элементе AngularJS, это потому, что
вы либо забыли загрузить библтотеку JQuery, либо забыли загрузить ее **ПЕРЕД** загрузкой AngularJS. Если AngularJS не 
увидит JQuery ко времени своей загрузки, то вместо неё будет использовать свою собственную библиотеку jqlite.

## $attributes.$observe()

Если имеется _соседский_ атрибут, который будет содержать `{{}}` то этот атрибут будет вычислен и даже может 
измениться несколько раз. **Не делайте это вручную!**

Вместо этого используйте `$attributes.$observe('myOtherAttribute', function(newValue))` так, как если бы вы
использовали `$scope.$watch()`. Единственным отличием является первый аргумент, в котором содержится имя атрибута
(не выражения) и колбэк, принимающий только новое значение `newValue` (уже вычисленное). Так же колбэк будет 
запускаться повторно всякий раз при изменении вычисленного выражения.

**Примечание:** Это означает, что к этому атрибуту можно получить доступ только _асинхронно_

**Примечание:** Если необходимо получить доступ к _достоверному_ предварительно вычисленному значению атрибута, 
то нужно сделать это в КомпилирующейФункции

## Расширение директив

Lets say you want to use a 3rd-party directive, but you want to extend it without modifying it. There are several ways you can go about doing this.

### Global Configurations
Some well-designed directives (such as those found in AngularUI) can be configured globally so that you do not have to pass in your options into every instance.
### Require Directives
Create a new directive that assumes the first directive has already been applied. You can require it on a parent DOM element, OR on the same DOM element. If you need to access functionality found in the primary directive, make it exposed via the directive controller (this may require submitting a Pull Request or feature request to the plugin developer).  
<pre>
// <div a b></div>
ui.directive('a', function(){
  return {
    controller: function(){
      this.data = {}
      this.changeData = function( ... ) { ... }
    },
    link: ($scope, $element, $attributes, controller) {
      controller.data = { ... }
    }
  }
})
myApp.directive('b', function(){
  return {
    require: 'a',
    link: ($scope, $element, $attributes, aController) {
      aController.changeData()
      aController.data = { ... }
    }
  }
})
</pre>
### Stacking Directives
You can create a new directive with the exact same name as the original directive. Both directives will be executed. However, you can use the priority to control which directive fires first (again, may require a Pull Request or feature request)
<pre>
// <div a></div>
ui.directive('a', ... )
myApp.directive('a', ... )
</pre>
### Templating
You can leverage `<ng-include>` or simply create a directive that generates the HTML with the primary directive attached.
<pre>
// <div b></div>
ui.directive('a', ... )
myApp.directive('b', function(){
  return {
    template: '<div a="someOptions"></div>'
  }
})
</pre>
